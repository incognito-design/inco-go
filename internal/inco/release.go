// Code generated by inco. DO NOT EDIT.

package inco

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// releaseHeader is prepended to released files following Go's generated-code
// convention so that tools (and inco itself) know to skip them.
const releaseHeader = "// Code generated by inco. DO NOT EDIT.\n\n"

// Release reads the overlay from .inco_cache and produces release files.
//
// For each overlay entry whose original is a .inco.go file:
//   - The shadow content (with guards) is written as <base>.go (prepending
//     the generated-code header; //line directives are preserved for traces).
//   - The original .inco.go is renamed to .inco (backup — invisible to the
//     Go compiler).
//
// After release, plain "go build" compiles the guarded .go files.
// "inco release clean" restores the originals.
func Release(root string) {
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:26
	if !(root != "") {
		panic("Release: root must not be empty")
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:27

	ov := loadOverlay(root)
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:29
	if !(len(ov.Replace) > 0) {
		panic("Release: no overlay entries — run gen first")
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:30

	var released int
	for origPath, shadowPath := range ov.Replace {
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:33
		if !(strings.HasSuffix(origPath, ".inco.go")) {
			continue
		}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:34

		// 1. Read shadow content.
		shadowContent, err := os.ReadFile(shadowPath)
		_ = err // @inco: err == nil, -panic(err)
		if !(err == nil) {
			panic(err)
		}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:38

		// 2. Write <base>.go alongside the original.
		releasePath := releasePathFor(origPath)
		err = os.WriteFile(releasePath, []byte(releaseHeader+string(shadowContent)), 0o644)
		_ = err // @inco: err == nil, -panic(err)
		if !(err == nil) {
			panic(err)
		}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:43

		// 3. Rename foo.inco.go → foo.inco (backup).
		backupPath := backupPathFor(origPath)
		err = os.Rename(origPath, backupPath)
		_ = err // @inco: err == nil, -panic(err)
		if !(err == nil) {
			panic(err)
		}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:48

		rel, _ := filepath.Rel(root, releasePath)
		fmt.Fprintf(os.Stderr, "  %s\n", rel)
		released++
	}
	fmt.Fprintf(os.Stderr, "inco: released %d file(s)\n", released)
}

// ReleaseClean restores the project to its pre-release state.
//
// For each overlay entry whose original is a .inco.go file:
//   - The generated .go file is removed.
//   - The .inco backup is renamed back to .inco.go.
func ReleaseClean(root string) {
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:62
	if !(root != "") {
		panic("ReleaseClean: root must not be empty")
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:63

	ov := loadOverlay(root)
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:65
	if !(len(ov.Replace) > 0) {
		panic("ReleaseClean: no overlay entries")
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:66

	var cleaned int
	for origPath := range ov.Replace {
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:69
		if !(strings.HasSuffix(origPath, ".inco.go")) {
			continue
		}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:70

		releasePath := releasePathFor(origPath)
		backupPath := backupPathFor(origPath)

		// Remove generated .go file.
		if err := os.Remove(releasePath); err == nil {
			rel, _ := filepath.Rel(root, releasePath)
			fmt.Fprintf(os.Stderr, "  removed %s\n", rel)
		}

		// Restore .inco → .inco.go.
		if err := os.Rename(backupPath, origPath); err == nil {
			rel, _ := filepath.Rel(root, origPath)
			fmt.Fprintf(os.Stderr, "  restored %s\n", rel)
			cleaned++
		}
	}
	fmt.Fprintf(os.Stderr, "inco: restored %d file(s)\n", cleaned)
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

// loadOverlay reads and parses .inco_cache/overlay.json.
func loadOverlay(root string) Overlay {
	overlayPath := filepath.Join(root, ".inco_cache", "overlay.json")
	data, err := os.ReadFile(overlayPath)
	_ = err // @inco: err == nil, -panic(err)
	if !(err == nil) {
		panic(err)
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:99

	var ov Overlay
	err = json.Unmarshal(data, &ov)
	_ = err // @inco: err == nil, -panic(err)
	if !(err == nil) {
		panic(err)
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/release.inco.go:103
	return ov
}

// releasePathFor returns the .go path for a .inco.go source file.
//
//	/a/b/foo.inco.go → /a/b/foo.go
func releasePathFor(origPath string) string {
	return strings.TrimSuffix(origPath, ".inco.go") + ".go"
}

// backupPathFor returns the .inco backup path for a .inco.go source file.
//
//	/a/b/foo.inco.go → /a/b/foo.inco
func backupPathFor(origPath string) string {
	return strings.TrimSuffix(origPath, ".go")
}
