package inco

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// releaseHeader is prepended to released files following Go's generated-code
// convention so that tools (and inco itself) know to skip them.
const releaseHeader = "// Code generated by inco. DO NOT EDIT.\n\n"

// Release reads the overlay from .inco_cache and produces release files.
//
// For each overlay entry whose original is a .inco.go file:
//   - The shadow content (with guards) is written as <base>.go (prepending
//     the generated-code header; //line directives are preserved for traces).
//   - The original .inco.go is renamed to .inco (backup — invisible to the
//     Go compiler).
//
// After release, plain "go build" compiles the guarded .go files.
// "inco release clean" restores the originals.
func Release(root string) {
	// @require root != "" panic("Release: root must not be empty")

	ov := loadOverlay(root)
	// @require len(ov.Replace) > 0 panic("Release: no overlay entries — run gen first")

	var released int
	for origPath, shadowPath := range ov.Replace {
		if !strings.HasSuffix(origPath, ".inco.go") {
			continue
		}

		// 1. Read shadow content.
		shadowContent, _ := os.ReadFile(shadowPath) // @must

		// 2. Write <base>.go alongside the original.
		releasePath := releasePathFor(origPath)
		_ = os.WriteFile(releasePath, []byte(releaseHeader+string(shadowContent)), 0o644) // @must

		// 3. Rename foo.inco.go → foo.inco (backup).
		backupPath := backupPathFor(origPath)
		_ = os.Rename(origPath, backupPath) // @must

		rel, _ := filepath.Rel(root, releasePath)
		fmt.Fprintf(os.Stderr, "  %s\n", rel)
		released++
	}
	fmt.Fprintf(os.Stderr, "inco: released %d file(s)\n", released)
}

// ReleaseClean restores the project to its pre-release state.
//
// For each overlay entry whose original is a .inco.go file:
//   - The generated .go file is removed.
//   - The .inco backup is renamed back to .inco.go.
func ReleaseClean(root string) {
	// @require root != "" panic("ReleaseClean: root must not be empty")

	ov := loadOverlay(root)
	// @require len(ov.Replace) > 0 panic("ReleaseClean: no overlay entries")

	var cleaned int
	for origPath := range ov.Replace {
		if !strings.HasSuffix(origPath, ".inco.go") {
			continue
		}

		releasePath := releasePathFor(origPath)
		backupPath := backupPathFor(origPath)

		// Remove generated .go file.
		if err := os.Remove(releasePath); err == nil {
			rel, _ := filepath.Rel(root, releasePath)
			fmt.Fprintf(os.Stderr, "  removed %s\n", rel)
		}

		// Restore .inco → .inco.go.
		if err := os.Rename(backupPath, origPath); err == nil {
			rel, _ := filepath.Rel(root, origPath)
			fmt.Fprintf(os.Stderr, "  restored %s\n", rel)
			cleaned++
		}
	}
	fmt.Fprintf(os.Stderr, "inco: restored %d file(s)\n", cleaned)
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

// loadOverlay reads and parses .inco_cache/overlay.json.
func loadOverlay(root string) Overlay {
	overlayPath := filepath.Join(root, ".inco_cache", "overlay.json")
	data, _ := os.ReadFile(overlayPath) // @must

	var ov Overlay
	_ = json.Unmarshal(data, &ov) // @must
	return ov
}

// releasePathFor returns the .go path for a .inco.go source file.
//
//	/a/b/foo.inco.go → /a/b/foo.go
func releasePathFor(origPath string) string {
	return strings.TrimSuffix(origPath, ".inco.go") + ".go"
}

// backupPathFor returns the .inco backup path for a .inco.go source file.
//
//	/a/b/foo.inco.go → /a/b/foo.inco
func backupPathFor(origPath string) string {
	return strings.TrimSuffix(origPath, ".go")
}
