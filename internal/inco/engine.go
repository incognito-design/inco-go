// Code generated by inco. DO NOT EDIT.

package inco

import (
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"sync"
	"sync/atomic"

	"golang.org/x/tools/go/ast/astutil"
)

// ---------------------------------------------------------------------------
// Public types
// ---------------------------------------------------------------------------

// Engine scans Go source files for @inco: directives and produces an
// overlay that injects the corresponding if-statements at compile time.
type Engine struct {
	Root       string
	Overlay    Overlay
	importMap  map[string]string // lazily built: package name → import path
	importOnce sync.Once
}

// NewEngine creates an engine rooted at the given directory.
func NewEngine(root string) *Engine {
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:38
	if !(root != "") {
		panic("NewEngine: root must not be empty")
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:39
	return &Engine{
		Root:    root,
		Overlay: Overlay{Replace: make(map[string]string)},
	}
}

// ---------------------------------------------------------------------------
// Run — top-level entry point
// ---------------------------------------------------------------------------

// fileResult holds the output of processing a single source file.
type fileResult struct {
	Path       string
	SrcHash    string
	ShadowPath string
	ShadowData []byte // nil when reused from cache
	Cached     bool
}

// Run scans all Go source files under Root, processes @inco: directives,
// and writes the overlay + shadow files into .inco_cache/.
//
// Incremental: if a source file's content hash matches the manifest and
// the shadow file still exists, the file is skipped.
//
// File processing is parallelized across available CPUs.
func (e *Engine) Run() {
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:66
	if !(e != nil) {
		panic("Run: nil engine")
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:67
	if !(e.Root != "") {
		panic("Run: root must not be empty")
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:68

	oldManifest := e.loadManifest()
	oldOverlay := e.loadOverlayIfExists()
	paths := collectGoFiles(e.Root)

	// Process files concurrently.
	results := make([]fileResult, len(paths))
	workers := runtime.GOMAXPROCS(0)
	if workers > len(paths) {
		workers = len(paths)
	}

	var wg sync.WaitGroup
	var workerErr atomic.Value // stores first panic as error
	ch := make(chan int, len(paths))
	for i := range paths {
		ch <- i
	}
	close(ch)

	for w := 0; w < workers; w++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			defer func() {
				if r := recover(); r != nil {
					workerErr.CompareAndSwap(nil, fmt.Errorf("%v", r))
				}
			}()
			// Each goroutine gets its own fset to avoid contention.
			fset := token.NewFileSet()
			for idx := range ch {
				path := paths[idx]
				srcHash := hashFile(path)

				// Check cache: source unchanged & shadow file exists → reuse.
				if prev, ok := oldManifest.Files[path]; ok && prev.SrcHash == srcHash {
					if _, err := os.Stat(prev.ShadowPath); err == nil {
						results[idx] = fileResult{
							Path: path, SrcHash: srcHash,
							ShadowPath: prev.ShadowPath, Cached: true,
						}
						continue
					}
				}

				// Cache miss — remove stale shadow before generating new one.
				if old, ok := oldOverlay[path]; ok {
					os.Remove(old)
				}

				// Parse and process.
				f, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
				_ = err // @inco: err == nil, -panic(err)
				if !(err == nil) {
					panic(err)
				}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:122
				shadowData := e.generateShadow(path, f, fset)
				results[idx] = fileResult{
					Path: path, SrcHash: srcHash,
					ShadowData: shadowData,
				}
			}
		}()
	}
	wg.Wait()

	// Re-panic on main goroutine so guardPanic() in main() can catch it.
	if v := workerErr.Load(); v != nil {
		panic(v)
	}

	// Collect results sequentially — write shadows, build overlay & manifest.
	newManifest := &Manifest{Files: make(map[string]ManifestEntry)}
	var skipped int
	for _, r := range results {
		if r.Cached {
			e.Overlay.Replace[r.Path] = r.ShadowPath
			newManifest.Files[r.Path] = ManifestEntry{SrcHash: r.SrcHash, ShadowPath: r.ShadowPath}
			skipped++
		} else {
			e.writeShadow(r.Path, r.ShadowData)
			if sp, ok := e.Overlay.Replace[r.Path]; ok {
				newManifest.Files[r.Path] = ManifestEntry{SrcHash: r.SrcHash, ShadowPath: sp}
			}
		}
	}

	// Clean up shadows for source files that no longer exist.
	for srcPath, shadowPath := range oldOverlay {
		if _, ok := newManifest.Files[srcPath]; !ok {
			os.Remove(shadowPath)
		}
	}

	if len(e.Overlay.Replace) > 0 {
		e.writeOverlay()
		e.writeManifest(newManifest)
		processed := len(e.Overlay.Replace) - skipped
		fmt.Fprintf(os.Stderr, "inco: overlay written to %s (%d file(s) mapped, %d processed, %d cached)\n",
			filepath.Join(e.Root, ".inco_cache", "overlay.json"),
			len(e.Overlay.Replace), processed, skipped)
	} else {
		e.writeManifest(newManifest)
	}
}

// ---------------------------------------------------------------------------
// File processing
// ---------------------------------------------------------------------------

// generateShadow produces the shadow file content for a source file.
// It is safe to call from multiple goroutines — it only reads e.Root
// and uses the provided fset.
func (e *Engine) generateShadow(path string, f *ast.File, fset *token.FileSet) []byte {
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:180
	if !(path != "") {
		panic("generateShadow: empty path")
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:181
	if !(f != nil) {
		panic("generateShadow: nil AST")
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:182
	// 1. Collect directive lines from AST comments.
	directives := make(map[int]*Directive) // 1-based line → Directive
	for _, cg := range f.Comments {
		for _, c := range cg.List {
			d := ParseDirective(c.Text)
			if d != nil {
				line := fset.Position(c.Pos()).Line
				directives[line] = d
			}
		}
	}

	// 2. Read source as lines.
	src, err := os.ReadFile(path)
	_ = err // @inco: err == nil, -panic(err)
	if !(err == nil) {
		panic(err)
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:197
	lines := strings.Split(string(src), "\n")

	// 3. Classify directives as standalone or inline using AST.
	standalone := make(map[int]*Directive)
	inline := make(map[int]*Directive)

	stmtLines := collectStmtLines(f, fset)
	for lineNum, d := range directives {
		idx := lineNum - 1
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:206
		if !(idx >= 0 && idx < len(lines)) {
			continue
		}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:207
		trimmed := strings.TrimSpace(lines[idx])
		isCommentLine := strings.HasPrefix(trimmed, "//") || strings.HasPrefix(trimmed, "/*")
		if isCommentLine {
			standalone[lineNum] = d
		} else if stmtLines[lineNum] {
			inline[lineNum] = d
		}
	}

	// 4. Build output.
	var output []string
	prevWasDirective := false

	for idx, line := range lines {
		lineNum := idx + 1

		if d, ok := standalone[lineNum]; ok {
			indent := extractIndent(line)
			output = append(output, fmt.Sprintf("//line %s:%d", path, lineNum))
			output = append(output, e.generateIfBlock(d, indent, path, lineNum))
			prevWasDirective = true
		} else if d, ok := inline[lineNum]; ok {
			output = append(output, line)
			indent := extractIndent(line)
			output = append(output, e.generateIfBlock(d, indent, path, lineNum))
			prevWasDirective = true
		} else {
			if prevWasDirective {
				output = append(output, fmt.Sprintf("//line %s:%d", path, lineNum))
				prevWasDirective = false
			}
			output = append(output, line)
		}
	}

	// 5. Add missing imports.
	content := strings.Join(output, "\n")
	content = e.addMissingImports(content, f, directives)

	return []byte(content)
}

// ---------------------------------------------------------------------------
// Code generation
// ---------------------------------------------------------------------------

// generateIfBlock returns the text of the injected if-statement.
//
//	if !(expr) {
//	    panic(...)
//	}
func (e *Engine) generateIfBlock(d *Directive, indent, path string, line int) string {
	cond := fmt.Sprintf("!(%s)", d.Expr)
	body := e.buildPanicBody(d, path, line)
	return fmt.Sprintf("%sif %s {\n%s\t%s\n%s}", indent, cond, indent, body, indent)
}

// buildPanicBody generates the action statement for @inco:.
//
//   - ActionReturn + args → return arg0, arg1, ...
//   - ActionReturn bare   → return
//   - ActionContinue      → continue
//   - ActionBreak         → break
//   - ActionPanic + args  → panic(arg)
//   - ActionPanic default → panic("inco violation: <expr> (at file:line)")
func (e *Engine) buildPanicBody(d *Directive, path string, line int) string {
	switch d.Action {
	case ActionReturn:
		if len(d.ActionArgs) > 0 {
			return "return " + strings.Join(d.ActionArgs, ", ")
		}
		return "return"
	case ActionContinue:
		return "continue"
	case ActionBreak:
		return "break"
	default: // ActionPanic
		if len(d.ActionArgs) > 0 {
			return "panic(" + d.ActionArgs[0] + ")"
		}
		relPath := path
		if rel, err := filepath.Rel(e.Root, path); err == nil {
			relPath = rel
		}
		msg := fmt.Sprintf("inco violation: %s (at %s:%d)", d.Expr, relPath, line)
		return fmt.Sprintf("panic(%q)", msg)
	}
}

// ---------------------------------------------------------------------------
// Import management
// ---------------------------------------------------------------------------

// buildImportMap dynamically resolves package names to import paths by
// querying the Go toolchain. The result is cached for the engine's lifetime
// so that "go list" runs at most once per invocation.
func (e *Engine) buildImportMap() map[string]string {
	e.importOnce.Do(func() {
		e.importMap = make(map[string]string)
		ambiguous := make(map[string]bool)

		// 1. All standard library packages.
		e.collectPackages(ambiguous, "std")

		// 2. Packages already used in the module (covers third-party deps).
		e.collectPackages(ambiguous, "-deps", "-e", "./...")

		// Remove ambiguous names (multiple import paths share a short name,
		// e.g. "template" → text/template vs html/template).
		for name := range ambiguous {
			delete(e.importMap, name)
		}
	})
	return e.importMap
}

// collectPackages runs "go list" with the given patterns and records
// each name → importPath pair in e.importMap.
func (e *Engine) collectPackages(ambiguous map[string]bool, patterns ...string) {
	args := append([]string{"list", "-e", "-f", "{{.Name}} {{.ImportPath}}"}, patterns...)
	cmd := exec.Command("go", args...)
	cmd.Dir = e.Root
	out, err := cmd.Output()
	_ = err // @inco: err == nil, -return
	if !(err == nil) {
		return
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:331
	for _, line := range strings.Split(strings.TrimSpace(string(out)), "\n") {
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:332
		if !(line != "") {
			continue
		}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:333
		parts := strings.SplitN(line, " ", 2)
		valid := len(parts) == 2 && parts[0] != "" && parts[0] != "main"
		_ = valid // @inco: valid, -continue
		if !(valid) {
			continue
		}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:336
		name, impPath := parts[0], parts[1]
		// Skip internal and vendored packages — they are not freely importable.
		internal := internalPkgRe.MatchString(impPath)
		_ = internal // @inco: !internal, -continue
		if !(!internal) {
			continue
		}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:340
		if existing, ok := e.importMap[name]; ok && existing != impPath {
			ambiguous[name] = true
		} else if !ambiguous[name] {
			e.importMap[name] = impPath
		}
	}
}

// pkgRefRe matches package-qualified identifiers like fmt.Errorf, errors.New.
var pkgRefRe = regexp.MustCompile(`\b([a-zA-Z_]\w*)\.\w+`)

// internalPkgRe matches import paths that are internal or vendored.
var internalPkgRe = regexp.MustCompile(`(^|/)internal/|(^|/)vendor/`)

// addMissingImports re-parses the shadow content, detects package references
// in directive action args, and adds missing imports via astutil.AddImport.
func (e *Engine) addMissingImports(content string, origFile *ast.File, directives map[int]*Directive) string {
	// 1. Collect all package-qualified identifiers from directives.
	needed := make(map[string]bool)
	for _, d := range directives {
		sources := d.ActionArgs
		if d.Expr != "" {
			sources = append(sources, d.Expr)
		}
		for _, s := range sources {
			for _, match := range pkgRefRe.FindAllStringSubmatch(s, -1) {
				needed[match[1]] = true
			}
		}
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:370
	if !(len(needed) > 0) {
		return content
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:371

	// 2. Determine which packages are already imported.
	imported := make(map[string]bool)
	for _, imp := range origFile.Imports {
		path := strings.Trim(imp.Path.Value, `"`)
		// Use local name if aliased, otherwise last segment.
		var name string
		if imp.Name != nil {
			name = imp.Name.Name
		} else {
			parts := strings.Split(path, "/")
			name = parts[len(parts)-1]
		}
		imported[name] = true
	}

	// 3. Find which needed packages are missing.
	importMap := e.buildImportMap()
	var toAdd []string
	for pkg := range needed {
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:391
		if !(!imported[pkg]) {
			continue
		}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:392
		if _, ok := importMap[pkg]; ok {
			toAdd = append(toAdd, pkg)
		}
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:396
	if !(len(toAdd) > 0) {
		return content
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:397

	// 4. Re-parse the shadow content and add imports via astutil.
	fset := token.NewFileSet()
	shadowAST, err := parser.ParseFile(fset, "", content, parser.ParseComments)
	_ = err // @inco: err == nil, -return(content)
	if !(err == nil) {
		return content
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:402
	for _, pkg := range toAdd {
		astutil.AddImport(fset, shadowAST, importMap[pkg])
	}

	// 5. Re-render.
	var buf strings.Builder
	err = format.Node(&buf, fset, shadowAST)
	_ = err // @inco: err == nil, -return(content)
	if !(err == nil) {
		return content
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:410
	return buf.String()
}

// ---------------------------------------------------------------------------
// Shadow & overlay I/O
// ---------------------------------------------------------------------------

func (e *Engine) writeShadow(origPath string, content []byte) {
	cacheDir := filepath.Join(e.Root, ".inco_cache")
	err := os.MkdirAll(cacheDir, 0o755)
	_ = err // @inco: err == nil, -panic(err)
	if !(err == nil) {
		panic(err)
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:421

	hash := sha256.Sum256(content)
	shadowName := fmt.Sprintf("%s_%x.go",
		strings.TrimSuffix(filepath.Base(origPath), ".go"),
		hash[:8])
	shadowPath := filepath.Join(cacheDir, shadowName)

	err = os.WriteFile(shadowPath, content, 0o644)
	_ = err // @inco: err == nil, -panic(err)
	if !(err == nil) {
		panic(err)
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:430
	e.Overlay.Replace[origPath] = shadowPath
}

func (e *Engine) writeOverlay() {
	cacheDir := filepath.Join(e.Root, ".inco_cache")
	err := os.MkdirAll(cacheDir, 0o755)
	_ = err // @inco: err == nil, -panic(err)
	if !(err == nil) {
		panic(err)
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:437
	data, err := json.MarshalIndent(e.Overlay, "", "  ")
	_ = err // @inco: err == nil, -panic(err)
	if !(err == nil) {
		panic(err)
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:439
	err = os.WriteFile(filepath.Join(cacheDir, "overlay.json"), data, 0o644)
	_ = err // @inco: err == nil, -panic(err)
	if !(err == nil) {
		panic(err)
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:441
}

// loadOverlayIfExists reads the previous overlay.json and returns the
// shadow path map. Returns nil if the file does not exist.
func (e *Engine) loadOverlayIfExists() map[string]string {
	overlayPath := filepath.Join(e.Root, ".inco_cache", "overlay.json")
	data, err := os.ReadFile(overlayPath)
	if err != nil {
		return nil
	}
	var ov Overlay
	if json.Unmarshal(data, &ov) != nil {
		return nil
	}
	return ov.Replace
}

// ---------------------------------------------------------------------------
// Manifest I/O (incremental gen)
// ---------------------------------------------------------------------------

func (e *Engine) manifestPath() string {
	return filepath.Join(e.Root, ".inco_cache", "manifest.json")
}

func (e *Engine) loadManifest() *Manifest {
	data, err := os.ReadFile(e.manifestPath())
	_ = err // @inco: err == nil, -return(&Manifest{Files: make(map[string]ManifestEntry)})
	if !(err == nil) {
		return &Manifest{Files: make(map[string]ManifestEntry)}
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:469
	var m Manifest
	if json.Unmarshal(data, &m) != nil || m.Files == nil {
		return &Manifest{Files: make(map[string]ManifestEntry)}
	}
	return &m
}

func (e *Engine) writeManifest(m *Manifest) {
	cacheDir := filepath.Join(e.Root, ".inco_cache")
	err := os.MkdirAll(cacheDir, 0o755)
	_ = err // @inco: err == nil, -panic(err)
	if !(err == nil) {
		panic(err)
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:480
	data, err := json.MarshalIndent(m, "", "  ")
	_ = err // @inco: err == nil, -panic(err)
	if !(err == nil) {
		panic(err)
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:482
	err = os.WriteFile(e.manifestPath(), data, 0o644)
	_ = err // @inco: err == nil, -panic(err)
	if !(err == nil) {
		panic(err)
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:484
}

// hashFile returns the hex-encoded SHA-256 of a file's contents.
func hashFile(path string) string {
	data, err := os.ReadFile(path)
	_ = err // @inco: err == nil, -panic(err)
	if !(err == nil) {
		panic(err)
	}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:490
	h := sha256.Sum256(data)
	return fmt.Sprintf("%x", h)
}

// ---------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------

// extractIndent returns the leading whitespace of a line.
func extractIndent(line string) string {
	return line[:len(line)-len(strings.TrimLeft(line, " \t"))]
}

// collectStmtLines walks the AST and returns a set of line numbers that
// contain statements inside function bodies. A directive comment whose
// line appears in this set is classified as "inline" rather than "standalone".
func collectStmtLines(f *ast.File, fset *token.FileSet) map[int]bool {
	lines := make(map[int]bool)
	ast.Inspect(f, func(n ast.Node) bool {
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:509
		if !(n != nil) {
			return false
		}
//line /Users/hitomikirigiri/Desktop/imnive/inco/internal/inco/engine.inco.go:510
		switch n.(type) {
		case *ast.AssignStmt, *ast.ExprStmt, *ast.ReturnStmt,
			*ast.IncDecStmt, *ast.SendStmt, *ast.GoStmt, *ast.DeferStmt,
			*ast.BranchStmt:
			lines[fset.Position(n.Pos()).Line] = true
		}
		return true
	})
	return lines
}
